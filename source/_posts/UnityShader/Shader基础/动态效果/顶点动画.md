---
title: 顶点动画
tags:
  - Shader
  - Shader基础
  - 动态效果
categories:
  - [技术美术, UnityShader，动态效果]
author:
  - nightstardawn
---

# 顶点动画
## 零、前置知识
</br>是否对SubShader进行批处理
`Tags{"DisableBatching" = "True/false"}`
</br>我们在制作顶点动画时，有时需要关闭该Shader的批处理
</br>因为我们在制作顶点动画的时候，有时需要使用模型空间下的数据
</br>而批处理会合并所有相关的模型，这些模型各自的模型空间会消失，导致我们无法正确使用模型空间下的相关数据

## 一、2D河流动画

### 1.基本原理
利用类似于机械波的波函数公式，对顶点进行位置偏移
</br>`某轴的位置偏移量 = 波动幅度 * sin(_Time.y * 波动频率 + 顶点某位置坐标 * 波长倒数)`
</br>其中，具体轴向根据模型空间决定
</br>波动幅度、波动频率、波长倒数为可调节参数

**注意：**
</br>在实现2D河流效果时，我们需要让顶点在模型空间下进行偏移
</br>需要关闭批处理
`Tags{"DisableBatching" = "false"}`
观察资源模型空间的的轴向，是否符合Unity轴向标准
### 2.基本实现思路
1. 属性声明、映射
   1. 主纹理
   2. 叠加颜色
   3. 波动幅度
   4. 波动频率
   5. 波长的倒数
2. 透明Shader相关
   1. 渲染标签相关
   </br>`Tags{"RenderType" = "Transparent" "Queue" = "Transparent" "IgnoreProject" = "True" "DisableBatching" = "false"}`
   2. 关闭深度写入、透明度混合
   </br>`ZWrite off | Blend SrcAlpha OneMinusSrcAlpha`
3. 结构体相关
    </br>顶点、uv
4. 顶点着色器
   <br>利用公式计算对应轴向偏移位置(模型空间中偏移)
5. 片元着色器
   <br>直接进行颜色采样和颜色叠加

### 3.实现示例
```csharp
Shader "Unlit/2DWater"
{
    Properties
    {
        _MainTex ("Texture", 2D) = "white" {}
        _Color ("Color", Color) = (1,1,1,1)
        //波动幅度
        _WaveAmplitude ("WaveAmplitude", Float) = 1
        //波动频率
        _WaveFrequency ("WaveFrequency", Float) = 1
        //波长的倒数
        _InWaveLength ("InWaveLength", Float) = 1
        //纹理变化速度
        _Speed ("Speed", Float) = 1
    }
    SubShader
    {
        //透明Shader渲染相关渲染标签 + 关闭批处理
        Tags { "RenderType"="Transparent" "Queue" = "Transparent" "IgnoreProjector" = "True" "DisableBatching" = "false"}

        Pass
        {
            ZWrite Off
            Blend SrcAlpha OneMinusSrcAlpha
            Cull Off
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #include "UnityCG.cginc"
            
            struct v2f
            {
                float2 uv : TEXCOORD0;
                float4 vertex : SV_POSITION;
            };

            sampler2D _MainTex;
            float4 _MainTex_ST;
            float4 _Color;
            float _WaveAmplitude;
            float _WaveFrequency;
            float _InWaveLength;
            float _Speed;
            v2f vert (appdata_base v)
            {
                v2f o;
                //模型空间下的偏移位置
                float4 offset;
                //这里使用的2D流水模型 上下是x轴，左右是z轴 前后是y轴
                //这里让它进在模型空间下的x进行偏移
                offset.x = sin(_Time.y * _WaveFrequency + v.vertex.z * _InWaveLength) * _WaveAmplitude;
                offset.yzw = float3(0,0,0);
                o.vertex = UnityObjectToClipPos(v.vertex + offset);
                //o.uv = v.texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
                o.uv = TRANSFORM_UV(v.texcoord);
                //结合纹理变化
                o.uv += float2(0,_Time.y * _Speed);
                return o;
            }

            fixed4 frag (v2f i) : SV_Target
            {
                fixed4 color = tex2D(_MainTex, i.uv);
                color.rgb *= _Color.rgb;
                return color;
            }
            ENDCG
        }
    }
}

```


## 二、广告牌效果

### 1.基本原理

广告牌效果 是一种图形技术
<br>用于确保对象(通常是二维纹理面片 或者 精灵(Sprite)图片) 始终面向摄像机\

- 全向广告牌效果
  <br>对象所在的Z轴始终面向摄像机 
  <br>适用与烟雾、火焰等效果
- 垂直广告牌效果
  <br>对象在一个特定轴向上保持固定方向，而在其他轴上面向摄像机
  <br>适用于 树木、花草、人物等需要在特定轴上保持正确方向的效果


基本原理：
旋转模型模型空间坐标系让其始终面向摄像机

1. 其中最重要的就是计算三个轴向
   <br>Z轴： normal = 将摄像机位置转移到模型空间下 - 模型空间下新轴向的中心点
   <br>原Y轴：oldUP = 模型空间下的Y轴(0，1，0)
   <br>X轴： right = cross(normal,oldUp)
   <br>新Y轴： newUp = cross(normal,right)
2. 计算模型空间下新的顶点位置
   1. 偏移位置 = 顶点坐标 - Center
   2. 新顶点位置 = Center + X轴 * 偏移位置.x + Y轴 * 偏移位置.y + Z轴 * 偏移位置.z
### 2.实现思路

1. 声明属性，属性映射
   <br>主纹理、颜色叠加、垂直广告牌程度(0为垂直广告牌，1为全向广告牌)
2. 透明Shader相关
   <br>注意:关闭批处理，并让其两面渲染 
3. 结构体相关
   <br>顶点和纹理坐标 
4. 顶点着色器
   <br>4-1:确定新坐标中心点
   <br>4-2:计算z轴(normal)，将摄像机坐标转到模型空间
   <br>4-3:用垂直广告牌程度改变z轴y值后，单位化
   <br>4-4:声明Y轴(old up)
   <br>4-5:利用Z轴(normal)和Y轴(old up)叉乘计算出X轴(right)
   <br>4-6:利用z轴(normal)和X轴(right)叉乘计算出Y轴(up)
   <br>4-7:得到顶点相对于新坐标系中心点的偏移位置
   <br>4-8:利用新中心点和3轴计算出顶点新位置
   <br>4-9:新顶点转到裁剪空间
   <br>4-8:UV缩放偏移
5. 片元着色器
   <br>直接采样 叠加颜色即可

### 3.实现示例

```csharp
Shader "Unlit/Billboarding"
{
    Properties
    {
        _MainTex ("Texture", 2D) = "white" {}
        _Color("Color", Color) = (1,1,1,1)
        //用于控制垂直广告牌和全向广告牌的变化
        _VerticalBillboarding("VerticalBillboarding", Range(0,1)) = 1
    }
    SubShader
    {
        Tags { "RenderType"="Transparent" "Queue"="Transparent" "IgnoreProjector"="True" "DisableBatching"="True" }

        Pass
        {
            ZWrite Off
            Blend SrcAlpha OneMinusSrcAlpha
            Cull Off

            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag

            #include "UnityCG.cginc"

            struct v2f
            {
                float2 uv : TEXCOORD0;
                float4 vertex : SV_POSITION;
            };

            sampler2D _MainTex;
            float4 _MainTex_ST;
            fixed4 _Color;
            float _VerticalBillboarding;

            v2f vert (appdata_base v)
            {
                v2f o;
                //新坐标系的中心点（默认我们使用的还是模型空间点的原点）
                float3 center = float3(0,0,0);
                //计算Z轴的方向
                float3 cameraInObjectPos = mul(unity_WorldToObject, float4(_WorldSpaceCameraPos, 1));
                //得到Z轴对应的向量
                float3 normalDir = cameraInObjectPos - center;
                //相当于把y轴往下压 如果_VerticalBillboarding=0 就代表我们把y轴压到了xz平面上 如果是1 就是正常的全方向的广告牌
                normalDir.y *= _VerticalBillboarding;
                //单位化Z轴的向量
                normalDir = normalize(normalDir);
                //模型空间下的Y轴正方向 作为它的oldUp
                //为了避免Z轴和010重合，因为重合后叉乘 会得到零向量
                float3 upDir = normalDir.y > 0.999 ? float3(0,0,1) : float3(0,1,0);
                //利用叉乘计算X轴的方向
                float3 rightDir = normalize(cross(upDir, normalDir));
                //计算我们的Y轴 也就是newUp
                upDir = normalize(cross(normalDir, rightDir));
                //得到顶点相对于新坐标系中心点的偏移量
                float3 centerOffset = v.vertex.xyz - center;
                //利用三个轴向进行最终的顶点计算
                float3 newVertexPos = center + rightDir * centerOffset.x + upDir * centerOffset.y + normalDir * centerOffset.z;
                //把新的顶点转换到裁剪空间中
                o.vertex = UnityObjectToClipPos(float4(newVertexPos, 1));
                //计算UV坐标
                o.uv = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;

                return o;
            }

            fixed4 frag (v2f i) : SV_Target
            {
                //对纹理采样
                float4 color = tex2D(_MainTex, i.uv);
                color.rgb *= _Color.rgb;
                return color;
            }
            ENDCG
        }
    }
}
```



















