---
title: 6_10
tags:
  - 算法
  - hot100
categories:
  - [算法]
author:
  - nightstardawn
---

# 一、三数之和

> 给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组

## 解题思路：

双指针
将题目转化为`num[i] + num[j] = -nums[k]`即可，在利用双指针的思路，转化为两数之和

# 二、接雨水

> 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

## 解题思路：

- 按列求(超时)
  关键点：通过求出最正在求的列，最大左右列，找出较矮的一端，和当前列比较，只有比当前列高，才会有水
- 动态规划->上一种方案的优化
  </br>关键点：用int[]保存第i列左/右的最大高度（不包括自身）。
  </br>max_left [i] = Max(max_left [i-1],height[i-1])
  </br>前边的墙的左边的最高高度和它前边的墙的高度选一个较大的，就是当前列左边最高的墙了。右边同理
- 单调栈
  
# 三、无重复字符的最长字串

> 给定一个字符串 s ，请你找出其中不含有重复字符的 最长 子串 的长度

## 解题思路：

滑动窗口

# 四、找到字符串中的所有字母的异位词

> 给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

## 解题思路：

滑动窗口
>先在 int[] count 里面存好 字符串p 的字母频率
</br>然后再在 s 里面用一个滑动窗口遍历，left 和 right 约束滑动窗口的范围。
</br>right 每往后移动一次，就在 count 里面减少 right 的位置对应的字母的数量，如果这个字母的数量变成负数了，就说明 right 移动多了（ 也就是在 left 和 right 之间包含的所有字母中出现了 p 中不应该出现的字母，这个不该出现的字母可能是 p 里面压根没有的，也可能是窗口范围内所有的这个字母的数量超过 p 中这个字母的数量了 ）这个时候就应该移动 left，直到把这个负数重新补成 0
</br>那么为什么 right 和 left 之间的长度等于 p 的长度的时候就可以直接得到答案呢？因为如果 right 和 left 之间的长度不等于 p 的长度，只有两种情况：
></br>如果 right - left + 1 < p.Length，此时肯定是不行的，想都不用想，数量都不够
></br>如果某一次 right 的移动使得 right - left + 1 > p.Length 了，此时必出现负数，left 也会必移动，直到把那个负数补回来
></br>所以当 right - left + 1 == p.Length 的时候，必有 count 里面全部都是 0，就不需要额外来判断 count 里面是不是全是 0 了

  
