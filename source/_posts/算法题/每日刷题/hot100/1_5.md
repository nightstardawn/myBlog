---
title: 1-5
tags:
  - 算法
  - hot100
categories:
  - [算法]
author:
  - nightstardawn
---

```csharp
//可能遇到的api

char[] array = str.ToCharArray();//将字符串转化为字符数组

Array.Sort(array);//排序数组

dictionary.TryAdd(key, new List<string>());//添加一个键值对到字典中，但是不会报错

```


# 一、两数之和

> 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</br>
> 你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。

你可以按任意顺序返回答案

## 解题思路：


通过哈希表的形式去检索`target-num`所对应的值即可

# 二、字母异位词分组

> 给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。
> </br>字母异位词 是由重新排列源单词的所有字母得到的一个新单词。

## 解题思路：

因为字母异位词可以看作包含的字符相同，而顺序不同
所以存在两种思路

- 一、将字符串通过一定的顺序排序，如果相同就可以视为一组
  </br>将确定顺序的字符串作为键，将这组词组成的列表作为值
- 二、字符串中每一个字符出现的次数一致，相同可以视为一组
  </br>由于每个字符串只包含小写字母，因此可以使用长度为 26 的数组记录每个字符的出现次数，将该数组转成字符串作为哈希表的键

# 三、最长连续序列

> 给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。
> </br>请你设计并实现时间复杂度为 O(n) 的算法解决此问题。

## 解决方案

哈希集合

注意点：
1. 判断num+1，num+2，num+3...是否在数组中。上面的代码是用直接遍历的方式去查找的，时间复杂度为O(n)，我们可以改为哈希表查找，时间复杂度为O(1)。
2. 遍历数组中每个元素num。逐一遍历每个元素会产生很多冗余工作，实际上我们无需一次针对每个元素num去判断num+1，num+2，num+3...是否在数组中。
   </br>如果num-1已经在数组中的话，那么num-1肯定会进行相应的+1遍历，然后遍历到num，而且从num-1开始的+1遍历必定比从num开始的+1遍历得到的序列长度更长。
   </br>因此，我们便可将在一个连续序列中的元素进行删减，让其只在最小的元素才开始+1遍历。
   - 比如，现有元素[1,2,4,3,5]，当2,3,4,5发现均有比自己小1的元素存在，那么它们就不会开始+1遍历，而1是连续序列中最小的元素，没有比自己小1的元素存在，所以会开始+1遍历。通过上述方式便可将时间复杂度优化至O(n)。

# 四、移动0
>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
> 请注意 ，必须在不复制数组的情况下原地对数组进行操作。

## 解决方案

双指针
左指针左边代表非零数，右指针右边代表0

# 盛水最多的容器

> 给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。
> </br>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
> </br>返回容器可以储存的最大水量

## 解决方法

双指针

左指针代表左左边界，右指针代表右边界

i从数组头开始，j从数组尾开始










